<!-- <!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Vite App</title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/r9/Tween.js"
        integrity="sha512-UPSdBfz8DCSlKWdGivt5XAyv0+RDb+Q0eZW2XQtblNeiqTybtt/60ob3GUyrLTJfeOLkSHCl3wN37q/fYbBH/A=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.154.0/three.module.js';

        const setupScene = async (isFall) => {
            try {
                // Fetch initial Bitcoin price
                const btcPrice = await fetchBitcoinPrice();
                // Log the initial Bitcoin price
                console.log('Initial Bitcoin Price:', btcPrice);

                // Define thresholds for Bitcoin price
                const thresholds = [100000, 250000, 500000, 1000000];
                let size;

                // Determine size based on Bitcoin price
                if (btcPrice < thresholds[0]) {
                    size = 20;
                } else if (btcPrice < thresholds[1]) {
                    size = 28;
                } else if (btcPrice < thresholds[2]) {
                    size = 36;
                } else {
                    size = 44;
                }

                // Scene, camera, and renderer setup for Three.js
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true });

                // Set the camera positions (x, y, z)
                camera.position.z = size * 4;

                if (size === 20) {
                    camera.position.x = Math.random() * (120 - (-120)) + (-120);
                    camera.position.y = Math.random() * (40 - (-40)) + (-40);
                } else if (size === 28) {
                    camera.position.x = Math.random() * (160 - (-160)) + (-160);
                    camera.position.y = Math.random() * (56 - (-56)) + (-56);
                } else if (size === 36) {
                    camera.position.x = Math.random() * (200 - (-200)) + (-200);
                    camera.position.y = Math.random() * (72 - (-72)) + (-72);
                } else {
                    camera.position.x = Math.random() * (240 - (-240)) + (-240);
                    camera.position.y = Math.random() * (80 - (-80)) + (-80);
                }

                // Set the size of the renderer and clear color
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 1);
                // Append the renderer to the body of the document
                document.body.appendChild(renderer.domElement);

                // Define the geometry for the hexagons
                const radius = 0.8;
                const segments = 6;
                const geometry = new THREE.CircleGeometry(radius, segments);

                // Define the honeycomb pattern
                const gap = 0;
                const hexagons = [];

                // Create the hexagons for the honeycomb pattern
                for (let i = -size; i <= size; i++) {
                    for (let j = -size; j <= size; j++) {
                        const x = (i + j / 2) * (radius * 2 + gap);
                        const y = j * (radius * Math.sqrt(3) + gap);

                        // Only create hexagons inside a circle
                        const distance = Math.sqrt(x * x + y * y);
                        if (distance <= size * (radius * Math.sqrt(3) + gap)) {
                            const material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0 });
                            const hexagon = new THREE.Mesh(geometry, material);
                            hexagon.position.set(x, y, 0);
                            hexagon.velocity = new THREE.Vector3(0, 0, 0);
                            scene.add(hexagon);
                            hexagons.push(hexagon);
                        }
                    }
                }

                // Load image using the Three.js texture loader
                const loader = new THREE.TextureLoader();
                const texture = await new Promise((resolve, reject) => {
                    loader.load(
                        // Either used image from URL or from Public Folder.
                        'dave-netto-wWYwYiCoVwI-unsplash.jpg',
                        resolve,
                        undefined,
                        reject
                    );
                });

                // Create a canvas and draw the image onto it
                const img = texture.image;
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d', { willReadFrequently: true });
                canvas.width = img.width;
                canvas.height = img.height;
                context.drawImage(img, 0, 0, img.width, img.height);

                // Remove the previous renderer if it exists
                const oldRenderer = document.querySelector('canvas');
                if (oldRenderer) {
                    document.body.removeChild(oldRenderer);
                }

                // Append the renderer to the body of the document
                document.body.appendChild(renderer.domElement);

                // Apply image colors to hexagons
                hexagons.forEach((hexagon) => {
                    const x = Math.round(((hexagon.position.x + size * (radius * 2 + gap)) / (size * 2 * (radius * 2 + gap))) * img.width);
                    const y = Math.round(((hexagon.position.y + size * (radius * Math.sqrt(3) + gap)) / (size * 2 * (radius * Math.sqrt(3) + gap))) * img.height);
                    const pixel = context.getImageData(x, y, 1, 1).data;
                    const color = new THREE.Color('rgb(' + pixel[0] + ',' + pixel[1] + ',' + pixel[2] + ')');
                    hexagon.material.color = color;

                    // Opacity transition
                    new TWEEN.Tween(hexagon.material)
                        // Transition to opacity 1 in 2 seconds
                        .to({ opacity: 1 }, 2000)
                        .start();
                });

                if (isFall) {
                    // "Break" effect after 3 seconds
                    setTimeout(() => {
                        hexagons.forEach((hexagon) => {
                            // Add horizontal and vertical velocity
                            hexagon.velocity = new THREE.Vector3((Math.random() - 0.5) / 4, -Math.random() * 2, 0);

                            // Fade out transition
                            new TWEEN.Tween(hexagon.material)
                                // Transition to opacity 0 in 2 seconds
                                .to({ opacity: 0 }, 2000)
                                .start();
                        });
                    }, 3000);
                } else {
                    // "Break" effect after 3 seconds
                    setTimeout(() => {
                        hexagons.forEach((hexagon) => {
                            // Fade out transition
                            new TWEEN.Tween(hexagon.material)
                                // Transition to opacity 0 in 2 seconds
                                .to({ opacity: 0 }, 2000)
                                .start();
                        });
                    }, 3000);
                }

                // Animation loop
                const animate = () => {
                    requestAnimationFrame(animate);

                    // Update hexagon positions
                    hexagons.forEach((hexagon) => {
                        hexagon.position.add(hexagon.velocity);
                    });

                    // Update any running tweens
                    TWEEN.update();
                    // Render the scene with the camera
                    renderer.render(scene, camera);
                }

                // Start the animation loop
                animate();
            } catch (error) {
                // Log any errors that occur during the setup
                console.error('Error:', error);
            }
        }

        // Function to fetch Bitcoin price from CoinDesk API
        const fetchBitcoinPrice = async () => {
            // Fetch the current price of Bitcoin in USD from the CoinDesk API
            const response = await fetch('https://api.coindesk.com/v1/bpi/currentprice/BTC.json');
            // Parse the JSON response
            const data = await response.json();
            // Return the current price of Bitcoin in USD
            return data.bpi.USD.rate_float;
        }

        let lastPrice = 0;

        const updateBitcoinPrice = async () => {
            let isRunning = true;
            while (isRunning) {
                try {
                    const btcPrice = await fetchBitcoinPrice();
                    console.log('Bitcoin Price:', btcPrice);

                    // Check if the Bitcoin price has crossed a threshold
                    if (btcPrice !== lastPrice) {
                        if (btcPrice < lastPrice) {
                            // If Bitcoin price is less than Last price, set up the scene for fall
                            console.log('Bitcoin Price Falls');
                            await setupScene(true);
                        } else {
                            // If Bitcoin price is less than Last price, set up the scene for rise
                            console.log('Bitcoin Price Rises');
                            await setupScene(false);
                        }
                    }

                    // Update the last price
                    lastPrice = btcPrice;

                    // Update the new price in every 3 seconds
                    await new Promise(resolve => setTimeout(resolve, 3000));
                } catch (error) {
                    console.error('Error:', error);
                    // If there's an error, you may choose to stop the loop
                    // Alternatively, you can handle the error and continue the loop
                    // without stopping by setting 'isRunning' to 'true' here.
                    isRunning = false;
                }
            }
        };

        // Start updating Bitcoin price in the console log
        updateBitcoinPrice();

        // Call the setupScene function to start the scene and make true for falling
        setupScene(true);  
    </script>
</body>
</html> -->
















<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js Vite App</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <script src="/tween.min.js"></script>
  <script type="module">
    import * as THREE from "/three.min.js";
    const fetchBitcoinPrice = async () => {
      const response = await fetch("https://api.coindesk.com/v1/bpi/currentprice/BTC.json");
      const data = await response.json();
      return data.bpi.USD.rate_float;
    }
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1);
    const setupScene = async (isFall) => {
      try {
        const btcPrice = await fetchBitcoinPrice();
        const size = 17;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const xRange = Math.random() * ((size * 3.2) - (-size * 3.2) + 1) + (-size * 3.2);
        const yRange = Math.random() * ((size * 1.2) - (-size * 1.2) + 1) + (-size * 1.2);
        camera.position.x = xRange;
        camera.position.y = yRange;
        camera.position.z = size * 4;
        document.body.appendChild(renderer.domElement);
        const radius = 0.8;
        const segments = 48;
        const geometry = new THREE.CircleGeometry(radius, segments);
        const gap = 0.2;
        const figures = [];
        for (let i = -size; i <= size; i++) {
          for (let j = -size; j <= size; j++) {
            const x = (i + j / 2) * (radius * 2 + gap);
            const y = j * (radius * Math.sqrt(3) + gap);
            const distance = Math.sqrt(x * x + y * y);
            if (distance <= size * (radius * Math.sqrt(2) + gap)) {
              const material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0 });
              const figure = new THREE.Mesh(geometry, material);
              figure.position.set(x, y, 0);
              figure.velocity = new THREE.Vector3(0, 0, 0);
              scene.add(figure);
              figures.push(figure);
            }
          }
        }
        const redGeometry = new THREE.CircleGeometry(size / (Math.random() * (2.4 - 1.8 + 1) + 1.8) * (radius * Math.sqrt(2) + gap + 0), segments);
        const redMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide, transparent: true, opacity: 0 });
        const redLayer = new THREE.Mesh(redGeometry, redMaterial);
        redLayer.position.set(xRange, yRange, (Math.random() * (2) + 0));
        scene.add(redLayer);
        const loader = new THREE.TextureLoader();
        let imageUrl;
        if ((btcPrice >= 10000) && (btcPrice < 25000)) {
          imageUrl = "/i1.jpg";
        } else if ((btcPrice >= 25000) && (btcPrice < 50000)) {
          imageUrl = "/i2.jpg";
        } else if ((btcPrice >= 50000) && (btcPrice < 75000)) {
          imageUrl = "/i3.jpg";
        } else if ((btcPrice >= 75000) && (btcPrice < 100000)) {
          imageUrl = "/i4.jpg";
        } else {
          imageUrl = "/i5.jpg";
        }
        const texture = await new Promise((resolve, reject) => {
          loader.load(imageUrl, resolve, undefined, reject);
        });
        scene.rotation.z = Math.PI;
        scene.rotation.y = Math.PI;
        const img = texture.image;
        img.crossOrigin = "anonymous";
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d", { willReadFrequently: true });
        canvas.width = img.width;
        canvas.height = img.height;
        context.drawImage(img, 0, 0, img.width, img.height);
        const oldRenderer = document.querySelector("canvas");
        if (oldRenderer) {
          document.body.removeChild(oldRenderer);
        }
        document.body.appendChild(renderer.domElement);
        const minWidth = -img.width / 16;
        const maxWidth = img.width / 1.8;
        const minHeight = -img.height / 16;
        const maxHeight = img.height / 1.8;
        const randomWidth = Math.floor(Math.random() * (maxWidth - minWidth + 1)) + minWidth;
        const randomHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
        figures.forEach((figure) => {
          const x = Math.round(((figure.position.x + size * (radius * 2 + gap)) / (size * 2 * (radius * 2 + gap))) * img.width / 2 + randomWidth);
          const y = Math.round(((figure.position.y + size * (radius * 2 + gap)) / (size * 2 * (radius * 2 + gap))) * img.height / 2 + randomHeight);
          const pixel = context.getImageData(x, y, 1, 1).data;
          const color = new THREE.Color("rgb(" + pixel[0] + "," + pixel[1] + "," + pixel[2] + ")");
          figure.material.color = color;
          new TWEEN.Tween(figure.material)
            .to({ opacity: 1 }, 2000)
            .start();
        });
        new TWEEN.Tween(redMaterial)
          .to({ opacity: 1 }, 2000)
          .start();
        setTimeout(() => {
          figures.forEach((figure) => {
            if (isFall) {
              figure.velocity = new THREE.Vector3((Math.random() - 0.5) / 4, Math.random() * 2, 0);
            }
            new TWEEN.Tween(figure.material)
              .to({ opacity: 0 }, 2000)
              .start();
          });
          new TWEEN.Tween(redMaterial)
            .to({ opacity: 0 }, 2000)
            .start();
        }, 3000);
        const animate = () => {
          requestAnimationFrame(animate);
          figures.forEach((figure) => {
            figure.position.add(figure.velocity);
          });
          TWEEN.update();
          renderer.render(scene, camera);
        }
        animate();
        const resetScene = () => {
          geometry.dispose();
          redGeometry.dispose();
          figures.forEach(figure => {
            figure.material.dispose();
            scene.remove(figure);
          });
          texture.dispose();
          scene.remove(redLayer);
        };
        setTimeout(() => {
          resetScene()
        }, 5000); // 2000 + 3000
      } catch (error) {
        console.error("Error:", error);
      }
    }
    let lastPrice = 0;
    let timeoutRef;
    const updateBitcoinPrice = async () => {
      let isRunning = true;
      while (isRunning) {
        try {
          const btcPrice = await fetchBitcoinPrice();
          console.log("Bitcoin Price:", btcPrice);
          if (btcPrice !== lastPrice) {
            clearTimeout(timeoutRef);
            if (btcPrice < lastPrice) {
              timeoutRef = setInterval(() => {
                setupScene(true);
              }, 6000);
            } else {
              timeoutRef = setInterval(() => {
                setupScene(false);
              }, 6000);
            }
          }
          lastPrice = btcPrice;
          await new Promise(resolve => setTimeout(resolve, 5000));
        } catch (error) {
          console.error("Error:", error);
          isRunning = false;
        }
      }
    };
    updateBitcoinPrice();
  </script>
</body>
</html>





















































// Import necessary components from the THREE library
import * as THREE from "/three.min.js";

// Function to fetch the current Bitcoin price
const fetchBitcoinPrice = async () => {
  // Send a request to the Coindesk API to fetch Bitcoin price data
  const response = await fetch("https://api.coindesk.com/v1/bpi/currentprice/BTC.json");
  const data = await response.json();
  // Extract and return the current Bitcoin price in USD
  return data.bpi.USD.rate_float;
}

// Create a WebGL renderer with antialiasing
const renderer = new THREE.WebGLRenderer({ antialias: true });

// Set the renderer figure size to match the window dimensions
renderer.setSize(window.innerWidth, window.innerHeight);

// Set the clear color of the renderer to black
renderer.setClearColor(0x000000, 1);

// Function to set up the scene and animate
const setupScene = async (isFall) => {
  try {
    // Fetch the current Bitcoin price
    const btcPrice = await fetchBitcoinPrice();

    // Calculate values based on Bitcoin price
    const ath = 68726;
    const threshold = 100000;
    const redSize = (ath - btcPrice) * 100 / threshold;
    const redRadius = 1.12;

    // Create a new Three.js scene
    const scene = new THREE.Scene();

    // Create a perspective camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // Set camera position based on calculated values
    const gap = 0.16;
    const figureRadius = 0.04 * (btcPrice / threshold) * 100;
    const figureSize = figureRadius / 0.04;
    const xFigure = Math.random() * ((figureSize * 3.6) - (-figureSize * 3.6) + 1) + (-figureSize * 3.6);
    const yFigure = Math.random() * ((figureSize * 0.4) - (-figureSize * 0.4) + 1) + (-figureSize * 0.4);
    const xRed = Math.random() * ((redSize * 4.08) - (-redSize * 4.08) + 1) + (-redSize * 4.08);
    const yRed = Math.random() * ((redSize * 0.48) - (-redSize * 0.48) + 1) + (-redSize * 0.48);

    // Set the camera's initial position
    camera.position.x = xFigure;
    camera.position.y = yFigure;
    camera.position.z = figureSize * 4;

    // Append the renderer's DOM element to the body
    document.body.appendChild(renderer.domElement);

    // Create a circle geometry for the figures
    const segments = 96;
    const figureGeometry = new THREE.CircleGeometry(figureRadius, segments);

    // Create arrays to hold figures and red layers
    const figures = [];

    // Iterate over positions and create figures
    for (let i = -figureSize; i <= figureSize; i++) {
      for (let j = -figureSize; j <= figureSize; j++) {
        // Calculate figure position
        const x = (i + j / 2) * (figureRadius * 2 + gap);
        const y = j * (figureRadius * Math.sqrt(3) + gap);
        const distance = Math.sqrt(x * x + y * y);

        // Check if the figure should be added
        if (distance <= figureSize * (figureRadius * Math.sqrt(2) + gap)) {
          // Create and configure figure
          const material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0 });
          const figure = new THREE.Mesh(figureGeometry, material);
          figure.position.set(x, y, 0);
          figure.velocity = new THREE.Vector3(0, 0, 0);
          scene.add(figure);
          figures.push(figure);
        }
      }
    }

    // Create and animate the red breathing layer
    const redGeometry = new THREE.CircleGeometry(redSize * (redRadius * Math.sqrt(2) + 0), segments);
    const redMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide, transparent: true, opacity: 0 });
    const redLayer = new THREE.Mesh(redGeometry, redMaterial);
    redLayer.position.set(xRed, yRed, 1);
    scene.add(redLayer);
    function animateBreathing() {
      // Animate the red layer's scale to create a breathing effect
      new TWEEN.Tween(redLayer.scale)
        .to({ x: 1.08, y: 1.08 }, 3000)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .onComplete(() => {
          new TWEEN.Tween(redLayer.scale)
            .to({ x: 1, y: 1 }, 3000)
            .easing(TWEEN.Easing.Quadratic.InOut)
            .onComplete(() => {
              // Restart the breathing animation
              animateBreathing();
            })
            .start();
        })
        .start();
    }
    animateBreathing();

    // Load image based on Bitcoin price range
    const loader = new THREE.TextureLoader();
    let imageUrl;
    if ((btcPrice >= 10000) && (btcPrice < 25000)) {
      imageUrl = "/i1.jpg";
    } else if ((btcPrice >= 25000) && (btcPrice < 50000)) {
      imageUrl = "/i2.jpg";
    } else if ((btcPrice >= 50000) && (btcPrice < 75000)) {
      imageUrl = "/i3.jpg";
    } else if ((btcPrice >= 75000) && (btcPrice < 100000)) {
      imageUrl = "/i4.jpg";
    } else {
      imageUrl = "/i5.jpg";
    }

    // Load texture and configure scene rotation
    const texture = await new Promise((resolve, reject) => {
      // Load the image texture
      loader.load(imageUrl, resolve, undefined, reject);
    });
    scene.rotation.z = Math.PI;
    scene.rotation.y = Math.PI;

    // Prepare image for color mapping
    const img = texture.image;
    img.crossOrigin = "anonymous";
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d", { willReadFrequently: true });
    canvas.width = img.width;
    canvas.height = img.height;
    context.drawImage(img, 0, 0, img.width, img.height);

    // Remove old renderer if exists and append new one
    const oldRenderer = document.querySelector("canvas");
    if (oldRenderer) {
      document.body.removeChild(oldRenderer);
    }
    document.body.appendChild(renderer.domElement);

    // Calculate dimensions for color mapping
    const minWidth = -img.width / 16;
    const maxWidth = img.width / 1.8;
    const minHeight = -img.height / 16;
    const maxHeight = img.height / 1.8;
    const randomWidth = Math.floor(Math.random() * (maxWidth - minWidth + 1)) + minWidth;
    const randomHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;

    // Map colors to figures based on image
    figures.forEach((figure) => {
      // Calculate pixel position on the image for the figure
      const x = Math.round(((figure.position.x + figureSize * (figureRadius * 2 + gap)) / (figureSize * 2 * (figureRadius * 2 + gap))) * img.width / 2 + randomWidth);
      const y = Math.round(((figure.position.y + figureSize * (figureRadius * 2 + gap)) / (figureSize * 2 * (figureRadius * 2 + gap))) * img.height / 2 + randomHeight);
      const pixel = context.getImageData(x, y, 1, 1).data;
      // Extract RGB values from the pixel and create a Three.js color
      const color = new THREE.Color("rgb(" + pixel[0] + "," + pixel[1] + "," + pixel[2] + ")");
      figure.material.color = color;
      // Animate the figure's opacity to make it visible
      new TWEEN.Tween(figure.material)
        .to({ opacity: 1 }, 2000)
        .start();
    });

    // Animate the opacity of the red layer
    new TWEEN.Tween(redMaterial)
      .to({ opacity: 1 }, 2000)
      .start();

    // Set a timeout to reset the scene after a delay
    setTimeout(() => {
      figures.forEach((figure) => {
        // Apply velocity to the figures for falling effect if necessary
        if (isFall) {
          figure.velocity = new THREE.Vector3((Math.random() - 0.5) / 4, Math.random() * 1.5, (Math.random() - 0.5));
        }
        // Animate the figure's opacity to make it disappear
        new TWEEN.Tween(figure.material)
          .to({ opacity: 0 }, 2000)
          .start();
      });
      // Animate the red layer's opacity to make it disappear
      new TWEEN.Tween(redMaterial)
        .to({ opacity: 0 }, 2000)
        .start();
    }, 4000);

    // Animation loop
    const animate = () => {
      // Continuously update and render the scene
      requestAnimationFrame(animate);
      figures.forEach((figure) => {
        figure.position.add(figure.velocity);
      });
      TWEEN.update();
      renderer.render(scene, camera);
    }
    animate();

    // Function to reset the scene
    const resetScene = () => {
      // Dispose of resources and remove figures and red layer from the scene
      figureGeometry.dispose();
      redGeometry.dispose();
      figures.forEach(figure => {
        figure.material.dispose();
        scene.remove(figure);
      });
      texture.dispose();
      scene.remove(redLayer);
    };

    // Set a timeout to reset the scene after a delay
    setTimeout(() => {
      resetScene();
    }, 6000);
  } catch (error) {
    // Handle errors during scene setup
    console.error("Error:", error);
  }
}

// Initialize variables for Bitcoin price tracking
let lastPrice = 0;
let timeoutRef;

// Function to continuously update Bitcoin price and trigger scene setup
const updateBitcoinPrice = async () => {
  let isRunning = true;
  while (isRunning) {
    try {
      // Fetch the current Bitcoin price
      const btcPrice = await fetchBitcoinPrice();
      console.log("Bitcoin Price:", btcPrice);

      // Check if the Bitcoin price has changed
      if (btcPrice !== lastPrice) {
        clearTimeout(timeoutRef);

        // Set up the scene based on the price trend
        if (btcPrice < lastPrice) {
          timeoutRef = setInterval(() => {
            // Set up the scene for falling figures
            setupScene(true);
          }, 8000);
        } else {
          timeoutRef = setInterval(() => {
            // Set up the scene for non-falling figures
            setupScene(false);
          }, 8000);
        }
      }

      // Update the last recorded price and wait for a delay
      lastPrice = btcPrice;
      await new Promise(resolve => setTimeout(resolve, 6000));
    } catch (error) {
      // Handle errors during Bitcoin price update
      console.error("Error:", error);
      isRunning = false;
    }
  }
};

// Start the Bitcoin price update loop
updateBitcoinPrice();
